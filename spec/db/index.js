// This file is autogenerated by the hyperdb compiler
/* eslint-disable camelcase */

const { IndexEncoder, c } = require('hyperdb/runtime')

const { version, getEncoding, setVersion } = require('./messages.js')

const helpers0 = require('../helpers.js')

// '@pear/dht' collection key
const collection0_key = new IndexEncoder([
], { prefix: 0 })

function collection0_indexify (record) {
  return []
}

// '@pear/dht' value encoding
const collection0_enc = getEncoding('@pear/dht')

// '@pear/dht' reconstruction function
function collection0_reconstruct (version, keyBuf, valueBuf) {
  setVersion(version)
  const record = c.decode(collection0_enc, valueBuf)
  return record
}
// '@pear/dht' key reconstruction function
function collection0_reconstruct_key (keyBuf) {
  return {}
}

// '@pear/dht'
const collection0 = {
  name: '@pear/dht',
  id: 0,
  encodeKey (record) {
    const key = []
    return collection0_key.encode(key)
  },
  encodeKeyRange ({ gt, lt, gte, lte } = {}) {
    return collection0_key.encodeRange({
      gt: gt ? collection0_indexify(gt) : null,
      lt: lt ? collection0_indexify(lt) : null,
      gte: gte ? collection0_indexify(gte) : null,
      lte: lte ? collection0_indexify(lte) : null
    })
  },
  encodeValue (version, record) {
    setVersion(version)
    return c.encode(collection0_enc, record)
  },
  trigger: null,
  reconstruct: collection0_reconstruct,
  reconstructKey: collection0_reconstruct_key,
  indexes: []
}

// '@pear/gc' collection key
const collection1_key = new IndexEncoder([
], { prefix: 1 })

function collection1_indexify (record) {
  return []
}

// '@pear/gc' value encoding
const collection1_enc = getEncoding('@pear/gc')

// '@pear/gc' reconstruction function
function collection1_reconstruct (version, keyBuf, valueBuf) {
  setVersion(version)
  const record = c.decode(collection1_enc, valueBuf)
  return record
}
// '@pear/gc' key reconstruction function
function collection1_reconstruct_key (keyBuf) {
  return {}
}

// '@pear/gc'
const collection1 = {
  name: '@pear/gc',
  id: 1,
  encodeKey (record) {
    const key = []
    return collection1_key.encode(key)
  },
  encodeKeyRange ({ gt, lt, gte, lte } = {}) {
    return collection1_key.encodeRange({
      gt: gt ? collection1_indexify(gt) : null,
      lt: lt ? collection1_indexify(lt) : null,
      gte: gte ? collection1_indexify(gte) : null,
      lte: lte ? collection1_indexify(lte) : null
    })
  },
  encodeValue (version, record) {
    setVersion(version)
    return c.encode(collection1_enc, record)
  },
  trigger: null,
  reconstruct: collection1_reconstruct,
  reconstructKey: collection1_reconstruct_key,
  indexes: []
}

// '@pear/bundle' collection key
const collection2_key = new IndexEncoder([
  IndexEncoder.STRING
], { prefix: 2 })

function collection2_indexify (record) {
  const a = record.link
  return a === undefined ? [] : [a]
}

// '@pear/bundle' value encoding
const collection2_enc = getEncoding('@pear/bundle/hyperdb#2')

// '@pear/bundle' reconstruction function
function collection2_reconstruct (version, keyBuf, valueBuf) {
  const key = collection2_key.decode(keyBuf)
  setVersion(version)
  const record = c.decode(collection2_enc, valueBuf)
  record.link = key[0]
  return record
}
// '@pear/bundle' key reconstruction function
function collection2_reconstruct_key (keyBuf) {
  const key = collection2_key.decode(keyBuf)
  return {
    link: key[0]
  }
}

// '@pear/bundle'
const collection2 = {
  name: '@pear/bundle',
  id: 2,
  encodeKey (record) {
    const key = [record.link]
    return collection2_key.encode(key)
  },
  encodeKeyRange ({ gt, lt, gte, lte } = {}) {
    return collection2_key.encodeRange({
      gt: gt ? collection2_indexify(gt) : null,
      lt: lt ? collection2_indexify(lt) : null,
      gte: gte ? collection2_indexify(gte) : null,
      lte: lte ? collection2_indexify(lte) : null
    })
  },
  encodeValue (version, record) {
    setVersion(version)
    return c.encode(collection2_enc, record)
  },
  trigger: null,
  reconstruct: collection2_reconstruct,
  reconstructKey: collection2_reconstruct_key,
  indexes: []
}

// '@pear/bundle-by-tags' collection key
const index3_key = new IndexEncoder([
  IndexEncoder.STRING,
  IndexEncoder.STRING
], { prefix: 3 })

// '@pear/bundle-by-tags' has the following schema defined key map
const index3_map = helpers0.tags

function index3_indexify (record) {
  const a = record
  return a === undefined ? [] : [a]
}

// '@pear/bundle-by-tags'
const index3 = {
  name: '@pear/bundle-by-tags',
  id: 3,
  encodeKey (record) {
    return index3_key.encode(index3_indexify(record))
  },
  encodeKeyRange ({ gt, lt, gte, lte } = {}) {
    return index3_key.encodeRange({
      gt: (gt || gt === '') ? index3_indexify(gt) : null,
      lt: (lt || lt === '') ? index3_indexify(lt) : null,
      gte: (gte || gte === '') ? index3_indexify(gte) : null,
      lte: (lte || lte === '') ? index3_indexify(lte) : null
    })
  },
  encodeValue: (doc) => index3.collection.encodeKey(doc),
  encodeIndexKeys (record, context) {
    const mapped = index3_map(record, context)
    const keys = new Array(mapped.length)
    for (let i = 0; i < mapped.length; i++) {
      const mappedRecord = mapped[i]
      keys[i] = index3_key.encode([mappedRecord, record.link])
    }
    return keys
  },
  reconstruct: (keyBuf, valueBuf) => valueBuf,
  offset: collection2.indexes.length,
  collection: collection2
}
collection2.indexes.push(index3)

module.exports = {
  version,
  collections: [
    collection0,
    collection1,
    collection2
  ],
  indexes: [
    index3
  ],
  resolveCollection,
  resolveIndex
}

function resolveCollection (name) {
  switch (name) {
    case '@pear/dht': return collection0
    case '@pear/gc': return collection1
    case '@pear/bundle': return collection2
    default: return null
  }
}

function resolveIndex (name) {
  switch (name) {
    case '@pear/bundle-by-tags': return index3
    default: return null
  }
}
